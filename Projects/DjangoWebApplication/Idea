The goal is to learn how to use Django Framework to build a web application that provides:
1. user profile creation and deletion
2. authentication, password management
3. creating/editing/deleting blog posts
4. admin functionalities for the web-application

installed django using pip install command
started a project using django-admin startproject <django_project_name>
django created the project folder with the following structure :
   - Manage.py allows us to run command line commands
   - __init__.py file to inform the interpreter that current package is a python project
   - settings.py file has settings information like secret_key, debug setting etc
   - urls.py file to store redirect url
   - wsgi.py file for communication between web application and web server

To start run the server and pull default site
    -execute the manage.py file using python manage.py runserver command
        This command provides the default webpage from the django framework at the address
        http://localhost:8000/ or  http://127.0.0.1:8000/
    -To access the default admin page: enter admin/ in front of the http://localhost:8000/ to go to admin page
        http://localhost:8000/admin/
        The routing to the admin page is done via urls.py file using the admin.site.urls in the path instruction

To stop running the server, ctrl+c on the command line

It is generally a good practice to have separate apps run on the website, wherein each app has a different purpose.
Example: blog app for managing blogs where as store app for managing the store of the website

To create blog app for our project:
    - run python manage.py startapp blog
    - create the blog folder structure

views.py file to creating the view of the app
    - create function in view.py called home for handling all the httprequests http://127.0.0.1:8000/blog
        - when the url path is an empty string then the home function returns as the http response a webpage with headline "Blog Home"
    - create function in view.py called about for handling all the httprequests http://127.0.0.1:8000/blog/about
        - when the url path is contains "about/" string then the about function returns as the http response a webpage with headline "Blog About"
The responses to the requested urls is calculated by proper referencing in the blog\urls.py and django_project\urls.py file
    - when the request is made, the django_project\urls.py file is checked for the paths.
    - all paths containing the "blog" references are then forwarded to blog\urls.py
        - during forwarding the string is chopped off until the matched and processed pattern in the request
          i.e. the request "http://127.0.0.1:8000/blog/about/" is chopped off "http://127.0.0.1:8000/blog/" and only "about/" is forwarded
    - in the blog\urls.py file, the check for the corresponding path is done and the function from views.py file is called.
To make the home page the default/landing page of the http request http://127.0.0.1:8000, keep the home page as the empty url instead of "blog/"
So change made to the django_project\urls.py:
    -   change from path('blog/', include('blog.urls') to path('', include('blog.urls'))


The http response for blog app can be build by using templates.
The templates are placed in the "templates" folder in the application folder as django by default searches for the templates/<app_name> folder.
For each of the routes, create an html page. In this example, it is home.html and about.html.

The <application>/apps.py i.e. <blog/apps.file> file has the class name which is used in the <django_project>/setting.py file.
The class name is added in the INSTALLED_APPS list in the string formed by '<application_name.apps.classname>' i.e.'blog.apps.BlogConfig'
After the application name is added, the HTTPResponse in the <application>/views.py file, need to be changed.
The changed returned value is to load and render the template instead of sending a direct HTTP response.
The loading and rendering of the template is automatically handled by django, shortcuts module , render function.

To access the variables passed in the render function to the template, create a list of values. example: list of dictionaries
where in each dictionary has key:value pairs. This list is then used in another dictionary which is passed to the render function.
The dictionary contains the list as the value.
In the templates file, the list is looped over to fetch the values.

Updated then the if/else block in the title section of the templates so that the pages have default title incase no title is provided as input.
TEMPLATE INHERITANCE:
    - to avoid duplication of the code between templates ( example the default page name ), the concept of template inheritance can be used.
    - create a new base.html file and copy the common content between the templates
    - the content marked as "{% block content%}{%end block%}" is overwritten by child templates
    - in the child templates, indicate that it extends the base.html template by adding the instructions:
        - {% extends "blog/base.html" %}
        - the code to be overwritten is mentioned between the quotes: {% block content %} and {% endblock content%}

Use bootstrap library to style the webpage.
To add the bootstrap, use the starter template and add the required sections like <Required meta tags>, <Bootstrap CSS>, and in the body, add the js scripts.
There are no packages needed to be installed as the library functions are provided via content delivery

Addition of navigation bar and styling information.

ADMIN PAGE:
    - creation of the super user done via manage.py file .
    - command to run : python manage.py createsuperuser
        - throws an error without a database as no database to save the super user .
    DATABASE CREATION:
        - database is created using the python manage.py makemigrations
        - to apply migrations made, run the command python manage.py migrate
        - run the command to create the super user and this time it works
            -superuser created with username: sumandb
            -email:tsui.champ@gmail.com
            -password:testing321
        - now after login, the built-in admin page is launched
            - provides a lot of built-in functionality like password hashing, user and group management
            - allows to add user, delete user
        - added another user
            - IvoErnst
            - kitten321

DATABASE MANAGEMENT:
    - creation of database tables
    - django has inbuilt orm ( object relation management)  which allows using the database in an easy to use oops.
    - orm allows different kind of dbs without changing the implementation
        - in current project, use sqlite during development and postgresql database during testing and deployment
        - allows database objects to be represented as class in the models.py file
        - all classes which are user defined are inheriting from the built-in models class
            - after the post class in the models.py file is created, with make migrations command django makes the xxx_initial.py file
            - the xxx_initial.py has the class Migrations specifying the model that would be applied
            - the python manage.py sqlmigrate <app_name> <num_of_initial.py> outputs the SQL query which will be generated by django
        - to start the shell command prompt, run python manage.py shell
        - to check the number of users created in the User table: run User.objects.all() command ( generic <table_name>.objects.all())
            - returns query set containing all the users
        - to get the first user run User.objects.first() command ( generic <table_name>.objects.first())
            - returns the User object
        - to filter the user object for specific user run User.objects.filter(username='IvoErnst').first() ( generic <table_name>.objects.filter(username=<value>))
        - to create a Post class object, call the Post class with the required arguments post_1 = Post(title ='Blog 1',content = 'My Favorite SchweineBraten Receipe',author=user)
        - to save the new post object to the database, run <object>.save()
        - run <table_name>.objects.all() to see if the changes were saved to the database
        - to access all the posts written by a user, run on the user object, user.post_set
            - django creates a built-in set on the related items between different models following the naming convention .modelname_set
            - user.post_set.all()
        - to create a post directly using the user object, run the create command on the user.post_set
            - example: user.post_set.create(title='Blog3', content = 'Bier ist mein Lieblingsgetraenk!')
            - after creating the post, there is no need to run the save function as the database is updated automatically
        - to grab the data from the database and pass the data to the view
            - open the blog/view.py
            - remove the dummy data and run query on post model
            - import the post model
            - write the query to fetch all the post objects and pass it as value to the dictionary key 'posts'
                -    context = {
                                'posts': Post.objects.all()
                               }
        - to get the models defined by the user in the admin page, register the models in the admin.py file
            - import the model
            - register the model by admin.site.register(<model_class_to_be_registered>>)

USER REGISTRATION

    - CREATE USER REGISTRATION PAGE
        - user registration management is separated logically from the blog app.
        - so to make the application maintainable, make the user registration app separately.
        - run python manage.py startapp users
        - after the users folder is created, register the app to the django project settings.py file,
            - add 'users.apps.UsersConfig', to INSTALLED_APPS
        - create a register function in the view.py file of the app
            - function takes a request and provides a form as a response to the user
            - using the inbuilt UserCreationForm class from django.contrib.auth.forms, create the variable to store the user creation form
            - render and return the page register.html from the templates/user folder.
        - register.html file has
            - the post method.
                - post method must have a CSRF token for security purpose
                - django does not allow the post method without the token
            - has the form
            - has the button to sign-up
            - has the option to login /signin if the user account already exists
        - in the view.py, register function request.method can be of two types. POST or GET
            - POST request method provides the user entered information back to the application.
                -if the form is valid, the application extracts the information
                    - creates the user in the database by calling save function on the form
                        - form.save()
                    - provides a small feedback in form of a message back to application via django.contrib.messages
                        - There are 5 types of message which can be shown by application
                            - messages.debug
                            - messages.info
                            - messages.error
                            - messages.warning
                            - messages.success
                        -  display success message
                            - messages.success(request, f"Account Created For {username}!")
                        - redirect to the home page after the display of the success message.
                            - to redirect use the inbuilt django.shortcuts redirect function
                                 return redirect('blog-home')
                        - in the base.html add the messages block :
                             {% if messages  %}
                                {% for message in messages  %}
                                    <div class = "alert alert-{{ message.tags }}">
                                        {{ message }}
                                    </div>
                                {% endfor %}
                            {% endif %}

            - GET request method the application creates an empty form and renders it

    - Creating the custom fields for the user creation form
        - create a new file called forms.py
        - create a new class which inherits from the UserCreationForm class of django.contrib.auth.forms
        - add the custom field 'email', which is required field by default
        - add the meta class
            - gives us a nested namespace for the configurations
            - which interacts with the model User and the fields which will be shown in the form
    - use the new UserRegisterForm in the views.py
    - the register form made prettier to show the error messages in highlight, to show the password requirements more muted
        - to do so 3rd party application called crispy forms can be used
        - crispy allows to make the forms sharper looking
        - pip install django-crispy-forms
        - include in the installed_apps of the setting.py file the crispy-forms application by adding
            INSTALLED_APPS = ['crispy_forms',]
        - indicate the use of bootstrap4 instead of default bootstrap2 to crispy-forms by adding to the settings.py file
            CRISPY_TEMPLATE_PACK = 'bootstrap4'
        - in the resister.html file, load the crispy forms by adding {% load crispy_forms_tags %}
        - change the form tag to use crispy filter by adding {{ form | crispy }}


AUTHENTICATION SYSTEM
    - user login/logout
        -user login
            - import default login, logout views from django in the <django-project>/urls.py file
                - import views from the django.contrib.auth
                - add the urls paths for login and logout
                    -path('login/', auth_view.LoginView.as_view(template_name = 'users/login.html'), name='login')
                        - template_name provides the html page that be used then login request is made
                    -path('logout/', auth_view.LogoutView.as_view(template_name = 'users/logout.html'), name='logout')
                         - template_name provides the html page that be used then logout request is made
                - add the login
                    -reuse the contents of the register.html file but change the button names and redirect href tags
                - after the login is done, django by default tries to load the account/profile.html file
                - to change this to load the home page, add the LOGIN_REDIRECT_URL = 'blog-home' instruction in the settings.py file
        -user logout
            - add the logout html file
            - reuse the contents of the register.html file but change the button names and redirect href tags
    - After sign-up:
        - after the user has signed-up and made an account, user must be redirected to the login page rather than the home page
        - to make this change, users/views.py, redirect the user to 'users-login'
    - Home page content based on authentication status
        -to change the view on the home page based on the user authentication
            i.e. login and register buttons should not be shown when the user has already logged in or registered
        -update the navigation bar conditionally based on the authentication status
            -in the base.html file, change the display of the login button and logout button based on the user.is_authenticated value
                    {% if user.is_authenticated %}
                      <a class="nav-item nav-link" href="{% url 'profile' %}">Profile</a>
                      <a class="nav-item nav-link" href="{% url 'logout' %}">Logout</a>
                    {% else %}
                      <a class="nav-item nav-link" href="{% url 'login' %}">Login</a>
                      <a class="nav-item nav-link" href="{% url 'register' %}">Register</a>
                    {% endif %}
            - after logging in the user now sees a profile page where his profile information is available
                - to do that, add a new route in the urls.py file
                - add the profile function in the view.py file
                    - renders and returns the profile.html file
                - create the profile.html file
                    - displays the username of currently logged in user
            - after logging out, the user can go visit his profile by change the url without logging in
                - to prevent that and to ensure that the profile page is shown only when the user is logged in,
                - use from the django.contrib.auth.decorators builtin decoration called @login_required above the profile function
                    - @login_required
                      def profile(request):
                            return render(request, 'users/profile.html')
                - add the login redirect url in settings.py file
                    - LOGIN_URL = 'login'




